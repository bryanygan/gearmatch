# GearMatch Product Database Scaling Roadmap

## Target Architecture: Hybrid (Client Scoring + Thin API)

Goal: Scale to 3,000-10,000 products while maintaining fast quiz experience

Approach:
- Keep quiz/scoring client-side (fast, no network latency)
- Add thin API layer for search, pagination, and pre-filtering
- Products stored as JSON, served via edge functions

================================================================================
CURRENT STATE
================================================================================

| Metric            | Value                                              |
|-------------------|----------------------------------------------------|
| Total Products    | 662 individual exports + 378 in monitors array     |
|                   | Breakdown: audio: 198, keyboards: 279, mice: 184,  |
|                   | monitors: 1 array export (allMonitorProducts[378]) |
| Data Size         | 2.4 MB TypeScript (67K lines)                      |
| Largest File      | monitors.ts (1.1 MB) — exports a single array      |
|                   | (allMonitorProducts: MonitorProduct[]) not 378      |
|                   | individual exports like other category files        |
| Architecture      | All data bundled client-side in Vite SPA            |
| Query Pattern     | O(n) in-memory array filtering                      |

Pain Points:
- Large file sizes make editing difficult
- All products load on initial page visit
- No search capability
- No pagination or lazy loading
- Adding products requires code changes
- Will not scale beyond ~3,000 products without UX degradation

================================================================================
PHASE 1: QUICK WINS (No Backend Required)
================================================================================

1.1 Dynamic Imports by Category                              ✅ DONE (423d10c)
--------------------------------
Split product loading so only the active category loads.

Changes made:
- src/data/products.ts - Converted to async getters with dynamic import()
- src/hooks/use-recommendations.ts - Replaced useMemo with useQuery
- src/lib/scoring/engine.ts - Made scoring functions async
- src/hooks/use-prefetch-products.ts - New prefetch hook
- Quiz pages - Added prefetch calls
- Test files - Updated with async/await

Result: Separate chunks per category (mice 244KB, audio 244KB, keyboards 525KB,
monitors 913KB). 214 tests pass. Users download only the category they need.


1.2 Enable React Query Caching                               ✅ DONE (423d10c)
-------------------------------
Completed as part of 1.1 — useQuery with staleTime: Infinity, gcTime: 30min.

================================================================================
PHASE 2: EXTRACT DATA TO JSON
================================================================================

2.1 Convert TypeScript to JSON Files                       ✅ DONE (beb594d)
-------------------------------------
Move product data out of source code.

New structure:
  src/data/products/
    mice.json      (182 products, 348 KB)
    keyboards.json (278 products, 675 KB)
    monitors.json  (378 products, 1.1 MB)
    audio.json     (197 products, 332 KB)

Changes made:
- src/data/products/*.json - Product data as validated JSON files
- src/lib/schemas/product-schemas.ts - Zod validation schemas for all 4 categories
- scripts/convert-ts-to-json.ts - Validation script (npm run convert:products)
- src/data/products.ts - Async getters with dynamic import() for JSON files

Result: Removed 67K lines of TypeScript data files, replaced with validated JSON.
Zod schemas enforce all enums, required fields, and type constraints.


2.2 Build-Time Validation                                  ✅ DONE
--------------------------
Add Vite plugin to validate JSON at build time.

Changes made:
- vite-plugins/validate-products.ts - Vite plugin using Zod schemas
- vite.config.ts - Plugin registered in plugins array
- tsconfig.node.json - Includes vite-plugins directory

Result: Every `npm run build` and `npm run dev` validates all product JSON
against Zod schemas. Invalid data fails the build with clear error messages
showing the exact field path and issue. 214 tests pass.

================================================================================
PHASE 3: THIN API LAYER (Cloudflare Pages Functions)             ✅ DONE
================================================================================

Architecture: Static JSON on CDN + Cloudflare Pages Functions
Platform: Cloudflare Pages (ASSETS binding for static JSON, zero external infra)

3.1 Product API Endpoints                                        ✅ DONE
--------------------------

Files created:
- functions/api/_middleware.ts - CORS, rate limiting, security headers
- functions/api/products/[category].ts - GET paginated products by category
- functions/api/products/search.ts - GET full-text search across products
- functions/api/products/filter.ts - POST pre-filter candidates for scoring
- public/data/products/*.json - Static copies of product JSON for API access

Endpoints:
  GET /api/products/mice?page=1&limit=50
  GET /api/products/search?q=razer&category=mouse
  POST /api/products/filter  (body: { category, answers, maxCandidates? })


3.2 Security                                                     ✅ DONE
-------------

Implemented in functions/api/_middleware.ts:

CORS: Preflight handling, configurable ALLOWED_ORIGIN (default "*" for dev,
  set to app origin in prod via wrangler.toml [vars]).

Rate Limiting: In-memory Map per isolate.
  - Search: 30 req/min/IP (via CF-Connecting-IP header)
  - Filter: 10 req/min/IP

Security Headers: X-Content-Type-Options: nosniff, X-Frame-Options: DENY,
  Strict-Transport-Security (1 year + includeSubDomains), Content-Type: application/json.

Input Validation:
  - Filter endpoint validates answers against category-specific Zod schemas
    (shared from src/lib/validation/quiz-schemas.ts, bundled by wrangler esbuild)
  - Search validates q param (1-100 chars, trimmed, lowercased)
  - Category endpoint validates category enum and pagination params


3.3 Smart Pre-Filtering                                          ✅ DONE
------------------------

Implemented in functions/api/products/filter.ts and
  src/hooks/use-pre-filtered-recommendations.ts.

Flow:
1. Client sends quiz answers to POST /api/products/filter
2. API validates answers with Zod, applies category-specific hard filters:
   - Mice: wireless (bool), handedness (left users need left/ambi)
   - Audio: audio_has_mic (if essential), wireless (if required), price_tier
   - Keyboards: wireless (if essential), price_tier
   - Monitors: size_class (within 1 step), resolution_class (within 1 step), price_tier
3. Returns candidate IDs (fallback: returns all if <10 candidates)
4. Client filters products to candidates, scores client-side

Feature flag: USE_API_PREFILTER (default false) in use-pre-filtered-recommendations.ts.
Graceful degradation: falls back to full client-side scoring if API fails.


3.4 Client Integration                                           ✅ DONE
------------------------

Files created:
- src/lib/api/types.ts - API request/response type definitions
- src/lib/api/client.ts - Fetch wrapper (productsApi.getByCategory/search/filter)
- src/hooks/use-products-api.ts - React Query hooks (staleTime 5min)
- src/hooks/use-pre-filtered-recommendations.ts - Integration hook

Client hooks return same RecommendationResult<T> interface as existing hooks.
Results pages need zero changes.


3.5 Infrastructure                                               ✅ DONE
-------------------

- wrangler.toml - Cloudflare Pages local dev config
- package.json scripts:
  - "dev:api" - wrangler pages dev + Vite (local API testing)
  - "copy:products" - copies src/data/products/*.json to public/data/products/
  - "build" - updated to run copy:products before vite build
- Dev deps: wrangler, @cloudflare/workers-types

================================================================================
PHASE 4: PERFORMANCE OPTIMIZATION
================================================================================

4.1 Web Worker Scoring                                          ✅ DONE
-----------------------
Move scoring engine to Web Worker to prevent UI blocking.

Files created:
- src/lib/scoring/worker/scoring.worker.ts - Worker that loads products
  internally, applies pre-filters, and scores. No large postMessage payloads.
- src/lib/scoring/worker/client.ts - Main-thread wrapper with same async
  interface. Single worker instance, request-ID promise resolution.
- src/lib/scoring/worker/index.ts - Barrel export

Changes:
- src/hooks/use-recommendations.ts - USE_WORKER_SCORING feature flag
  (default false). Each hook conditionally dynamic-imports worker client.
- src/lib/scoring/index.ts - Re-exports worker functions
- vite.config.ts - Added worker.format: "es" for code-splitting support

Result: Worker chunk emitted in build (scoring.worker-*.js). Feature flag
  toggles between main-thread and worker scoring. Same results either way.


4.2 Pre-Filtering Strategy                                     ✅ DONE
---------------------------
Client-side pre-filters eliminate obvious mismatches before scoring.
Only hard constraints are filtered (e.g. wireless required → eliminate wired).

Files created:
- src/lib/filtering/types.ts - PreFilter<TAnswers, TProduct> type
- src/lib/filtering/apply-filters.ts - Generic applyPreFilters() runner
- src/lib/filtering/mouse-filters.ts - wirelessFilter, handednessFilter
- src/lib/filtering/audio-filters.ts - micFilter, wirelessFilter
- src/lib/filtering/keyboard-filters.ts - connectivityFilter
- src/lib/filtering/monitor-filters.ts - resolutionFilter, sizeFilter
- src/lib/filtering/index.ts - Barrel export

Changes:
- src/lib/scoring/engine.ts - Pre-filter step inserted before scoreProducts()
  in all 4 get*Recommendations() functions. totalEvaluated still shows full
  product count.

Result: 22 new tests pass. Pre-filters reduce scoring workload without
  affecting top pick quality (only eliminates definitionally wrong matches).


4.3 Product Indexing                                            DEFERRED
---------------------
Deferred — not needed at current scale (max 378 products per category).
O(n) property checks in pre-filters take <1ms. The pre-filtering strategy
(4.2) accomplishes the same goal more simply. Will revisit when product
counts exceed 3,000 per category.


4.4 Client-Side Search                                          ✅ DONE
-----------------------
Fuse.js fuzzy search across all products, surfaced via Cmd+K command palette.

Files created:
- src/lib/search/index.ts - Fuse.js module: initSearchIndex(), searchProducts(),
  toSearchable(). Keys: name(0.5), brand(0.3), tags(0.2), threshold 0.4.
- src/hooks/use-product-search.ts - useInitSearchIndex() loads all categories
  on first open (staleTime: Infinity). useProductSearch() with 150ms debounce.
- src/components/search/SearchBar.tsx - Cmd+K / Ctrl+K modal using existing
  CommandDialog component. Groups results by category with icons. Selecting
  navigates to /quiz/{category}.

Changes:
- src/App.tsx - Added <SearchBar /> inside BrowserRouter
- package.json - Added fuse.js dependency (~6KB gzipped)

Result: 11 new tests pass. Users can search all 1,040 products by name,
  brand, or tags from anywhere in the app via Cmd+K.

================================================================================
PHASE 5: DEVELOPER EXPERIENCE
================================================================================

5.1 Validation CLI
-------------------
Pre-commit hook to validate product JSON.

Files to create:
- scripts/validate-products.ts
- .husky/pre-commit

Checks: Schema compliance, duplicate IDs, URL validity.


5.2 CSV Import/Export
----------------------
Allow bulk editing via spreadsheet.

Files to create:
- scripts/import-csv.ts
- scripts/export-csv.ts
- docs/csv-format.md - Example CSV/YAML samples and field rules

Cell Sanitization (sanitizeCell in import-csv.ts):
- Neutralize formula injection for values starting with '=', '+', '-', '@'
  by prefixing with a single quote or escaping.
- Normalize/strip UTF-8 BOM from input files and unify line endings (CRLF → LF).

Row Validation (validateRow in import-csv.ts):
- Strict schema field checks against product Zod schemas.
- URL format validation (and optional reachability check).
- Price range sanity checks (min > 0, min < max, within category norms).
- Required field enforcement (id, name, brand, category).
- Duplicate product ID detection/handling (warn or reject).
- Schema-versioning checks to detect field drift between CSV and current schema.

Dry-Run / Preview Mode:
- import-csv.ts --dry-run flag: Perform full validation without writing changes.
- Produce a validation report (pass/fail per row, warnings, summary stats).
- Exit with non-zero code if any validation errors found.

Export (export-csv.ts):
- Include all fields defined in the Zod schema.
- Add header comments with schema version and export timestamp.
- Document field rules alongside exports for reviewable commits.


5.3 Admin UI (Optional)
------------------------
Simple product editor within the app. Requires authentication and role-based
authorization before any admin routes or components render.

Files to create:
- src/pages/admin/ProductList.tsx
- src/pages/admin/ProductEditor.tsx
- src/components/admin/AdminRouteGuard.tsx - Client-side auth/role gate

Authentication & Authorization:
- Require authenticated admin role via chosen provider (NextAuth/Clerk/Auth0)
  before rendering admin routes/components.
- AdminRouteGuard.tsx wraps all /admin/* routes — redirects unauthenticated
  or non-admin users to login or 403 page.
- Server-side guard checks on admin API endpoints (verify JWT/session and
  admin role before processing any write request).

Audit Logging:
- Log all product edits: who (user ID), what (product ID + field), when
  (timestamp), delta (old value → new value).
- Persist audit logs to an auditable store (database table, append-only log
  file, or external service like Datadog/Sentry).
- Surface recent edit history in the Admin UI for accountability.

Environment Isolation:
- Gate admin routes behind a feature flag (e.g., VITE_ENABLE_ADMIN=true)
  or build-time check so they are not exposed in unprotected production builds.
- Admin bundle should be code-split so it's never downloaded by regular users.

Features:
- List all products with search/filter
- Edit form with validation
- Download as JSON for commit
- View audit log of recent changes


5.4 GitHub Actions CI
----------------------
Automate validation on PRs.

Files to create:
- .github/workflows/validate-products.yml

================================================================================
RECOMMENDED IMPLEMENTATION ORDER
================================================================================

| Week  | Tasks                              | Impact                        | Status |
|-------|------------------------------------|-------------------------------|--------|
| 1-2   | JSON extraction + validation CLI   | Foundation for everything     | ✅ DONE |
| 3-4   | Dynamic imports + React Query      | 80% bundle reduction          | ✅ DONE |
| 5-6   | Edge functions API (search+filter) | Scalable to 10K products      | ✅ DONE |
| 7-8   | Pre-filter + Worker + Client Search| Fast scoring + search UX      | ✅ DONE |
| 9-10  | Admin UI + CSV import              | Non-dev editing               |        |

Why This Order?
1. JSON first - Everything else depends on data being in JSON format
2. Code splitting - Immediate performance win for existing users
3. API layer - Critical for scaling beyond 3K products
4. Web Workers - Nice-to-have optimization, not blocking
5. Admin UI - Improves DX but can manually edit JSON until then

================================================================================
CRITICAL FILES REFERENCE
================================================================================

| File                             | Purpose                              |
|----------------------------------|--------------------------------------|
| src/data/products.ts             | Central data access (refactor async) |
| src/lib/scoring/engine.ts        | Scoring logic (optimize for scale)   |
| src/types/products.ts            | Type definitions (Zod schema basis)  |
| src/hooks/use-recommendations.ts | React hooks (add React Query)        |
| vite.config.ts                   | Build config (add plugins)           |

================================================================================
VERIFICATION
================================================================================

After each phase:
1. Run `npm run build` - Verify bundle size reduction
2. Run `npm run dev` - Test quiz flow end-to-end
3. Check Lighthouse performance score
4. Verify all 4 quiz categories still return correct recommendations
