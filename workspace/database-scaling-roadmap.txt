# GearMatch Product Database Scaling Roadmap

## Target Architecture: Hybrid (Client Scoring + Thin API)

Goal: Scale to 3,000-10,000 products while maintaining fast quiz experience

Approach:
- Keep quiz/scoring client-side (fast, no network latency)
- Add thin API layer for search, pagination, and pre-filtering
- Products stored as JSON, served via edge functions

================================================================================
CURRENT STATE
================================================================================

| Metric            | Value                                              |
|-------------------|----------------------------------------------------|
| Total Products    | 662 individual exports + 378 in monitors array     |
|                   | Breakdown: audio: 198, keyboards: 279, mice: 184,  |
|                   | monitors: 1 array export (allMonitorProducts[378]) |
| Data Size         | 2.4 MB TypeScript (67K lines)                      |
| Largest File      | monitors.ts (1.1 MB) — exports a single array      |
|                   | (allMonitorProducts: MonitorProduct[]) not 378      |
|                   | individual exports like other category files        |
| Architecture      | All data bundled client-side in Vite SPA            |
| Query Pattern     | O(n) in-memory array filtering                      |

Pain Points:
- Large file sizes make editing difficult
- All products load on initial page visit
- No search capability
- No pagination or lazy loading
- Adding products requires code changes
- Will not scale beyond ~3,000 products without UX degradation

================================================================================
PHASE 1: QUICK WINS (No Backend Required)
================================================================================

1.1 Dynamic Imports by Category
--------------------------------
Split product loading so only the active category loads.

Files to modify:
- src/data/products.ts - Convert to async getters
- src/hooks/use-recommendations.ts - Use React Query for async loading
- src/lib/scoring/engine.ts - Make scoring functions async

Benefits: Users download 300KB (mice) instead of 2.6MB (all). Faster initial load.


1.2 Enable React Query Caching
-------------------------------
TanStack Query is already installed but unused.

Files to modify:
- src/hooks/use-recommendations.ts - Replace useMemo with useQuery

Benefits: Automatic caching, loading states, DevTools.

================================================================================
PHASE 2: EXTRACT DATA TO JSON
================================================================================

2.1 Convert TypeScript to JSON Files
-------------------------------------
Move product data out of source code.

New structure:
  data/
    products/
      mice.json
      keyboards.json
      monitors.json
      audio.json

Files to create:
- scripts/convert-ts-to-json.ts - Migration script
- src/lib/schemas/product-schemas.ts - Zod validation schemas

Safe Migration Workflow (scripts/convert-ts-to-json.ts):
- auditNonSerializable(): Scan TS product modules for functions, getters,
  computed properties, or symbols that won't JSON-serialize. Fail migration
  if any are found and report the offending fields.
- migrateAndCompare(): Write JSON output, then load both the original TS
  export and the generated JSON. Run deep comparison (compareProductObjects)
  to fail the migration on any missing fields or type changes.
- normalizeOptionalFields(): Codify an optional-field policy (undefined vs
  null vs omit) in product-schemas.ts. Normalize fields like manufacturer_url
  and retailer_urls during conversion so the JSON output is consistent.
- extractCommentsToMetadata(): Optionally preserve maintainer notes and
  update timestamps by extracting them into an explicit metadata field in
  each product's JSON representation.

Validation Schemas (src/lib/schemas/product-schemas.ts):
- Define Zod schemas for each product category matching TypeScript types
- Enforce the optional-field policy (choose undefined vs null vs omit)
- Validate URL formats, price ranges, enum values, and required fields

Benefits:
- Non-developers can edit JSON directly
- Better git diffs for data changes
- Foundation for admin tooling
- Can update data without full rebuild
- Migration is verified — no silent data loss


2.2 Build-Time Validation
--------------------------
Add Vite plugin to validate JSON at build time.

Files to create:
- vite-plugins/validate-products.ts

================================================================================
PHASE 3: THIN API LAYER (Edge Functions)
================================================================================

Architecture: Static JSON on CDN + Vercel/Cloudflare Edge Functions

3.1 Product API Endpoints
--------------------------

Files to create:
- api/products/[category].ts - Get products by category (paginated)
- api/products/search.ts - Full-text search across products
- api/products/filter.ts - Pre-filter candidates for scoring

Endpoints:
  GET /api/products/mice?page=1&limit=50
  GET /api/products/search?q=razer&category=mouse
  POST /api/products/filter  (body: quiz answers, returns candidate IDs)


3.2 Security
-------------

Authentication & Authorization:
- GET endpoints (/api/products/[category], /api/products/search) are public
  read-only — no auth required.
- POST /api/products/filter is public but requires input validation (see below).
- Any future write endpoints (admin CRUD) require authenticated admin role via
  the chosen auth provider (NextAuth/Clerk/Auth0).

Input Validation & Sanitization:
- POST /api/products/filter: Validate quiz answer payloads against a strict
  Zod schema. Reject malformed requests, unexpected fields, and values outside
  allowed enums. Sanitize string inputs to prevent injection.
- GET /api/products/search: Validate and sanitize the `q` parameter (max
  length, strip special characters, escape for search backend).

Rate Limiting:
- GET /api/products/search: Rate limit to prevent abuse (e.g., 30 req/min/IP).
- POST /api/products/filter: Rate limit to prevent quiz-spam (e.g., 10 req/min/IP).
- Options: Upstash Redis (edge-compatible), Cloudflare Rate Limiting (if using
  CF Workers), or Vercel's built-in edge rate limiting.

CORS & Headers:
- Set explicit CORS policy: allow only the app's own origin in production.
- Recommended headers for edge deployments: Content-Security-Policy, Strict-
  Transport-Security (HSTS), X-Content-Type-Options: nosniff, X-Frame-Options.

Monitoring & Logging:
- Log request volumes, error rates, and latency per endpoint.
- Alert on unusual traffic patterns (potential abuse or scraping).


3.3 Smart Pre-Filtering
------------------------

Instead of scoring ALL products client-side:
1. Client sends quiz answers to /api/products/filter
2. API applies hard filters (wireless required? budget limit?)
3. Returns ~100-200 candidate product IDs
4. Client fetches only those products and scores them

Benefits:
- User downloads 200 products (~500KB) instead of 5,000 (~12MB)
- Scoring 200 products takes ~20ms instead of ~1 second
- Works great on mobile and low-end devices


3.4 Hosting Options
--------------------

| Platform           | Pros                                    | Cons                    |
|--------------------|-----------------------------------------|-------------------------|
| Vercel Edge        | Easy Vite integration, generous free    | Vendor lock-in          |
| Cloudflare Workers | Fastest, great free tier                | Separate deploy process |
| Netlify Functions  | Simple setup                            | Slower cold starts      |

Recommended: Vercel (if already using) or Cloudflare Workers (best performance)

================================================================================
PHASE 4: PERFORMANCE OPTIMIZATION
================================================================================

4.1 Web Worker Scoring
-----------------------
Move scoring engine to Web Worker to prevent UI blocking.

Files to create:
- src/workers/scoring-worker.ts
- src/lib/scoring/worker-client.ts

Benefits: UI stays responsive during scoring of thousands of products.


4.2 Pre-Filtering Strategy
---------------------------
Filter products before scoring to reduce workload.

Example: If user requires wireless, eliminate 50% of products before scoring.


4.3 Product Indexing
---------------------
Create indices for common attributes.

Example:
  const indices = {
    byCategory: { mouse: ['id1', 'id2'], keyboard: ['id3'] },
    byWireless: { true: ['id1'], false: ['id2', 'id3'] },
    byPriceTier: { budget: ['id2'], premium: ['id1'] }
  };

Benefits: O(1) lookups instead of O(n) filtering.


4.4 Client-Side Search
-----------------------
Add Fuse.js for fuzzy search on product names/brands.

Files to create:
- src/lib/search/index.ts
- src/hooks/use-product-search.ts
- src/components/search/SearchBar.tsx

================================================================================
PHASE 5: DEVELOPER EXPERIENCE
================================================================================

5.1 Validation CLI
-------------------
Pre-commit hook to validate product JSON.

Files to create:
- scripts/validate-products.ts
- .husky/pre-commit

Checks: Schema compliance, duplicate IDs, URL validity.


5.2 CSV Import/Export
----------------------
Allow bulk editing via spreadsheet.

Files to create:
- scripts/import-csv.ts
- scripts/export-csv.ts
- docs/csv-format.md - Example CSV/YAML samples and field rules

Cell Sanitization (sanitizeCell in import-csv.ts):
- Neutralize formula injection for values starting with '=', '+', '-', '@'
  by prefixing with a single quote or escaping.
- Normalize/strip UTF-8 BOM from input files and unify line endings (CRLF → LF).

Row Validation (validateRow in import-csv.ts):
- Strict schema field checks against product Zod schemas.
- URL format validation (and optional reachability check).
- Price range sanity checks (min > 0, min < max, within category norms).
- Required field enforcement (id, name, brand, category).
- Duplicate product ID detection/handling (warn or reject).
- Schema-versioning checks to detect field drift between CSV and current schema.

Dry-Run / Preview Mode:
- import-csv.ts --dry-run flag: Perform full validation without writing changes.
- Produce a validation report (pass/fail per row, warnings, summary stats).
- Exit with non-zero code if any validation errors found.

Export (export-csv.ts):
- Include all fields defined in the Zod schema.
- Add header comments with schema version and export timestamp.
- Document field rules alongside exports for reviewable commits.


5.3 Admin UI (Optional)
------------------------
Simple product editor within the app. Requires authentication and role-based
authorization before any admin routes or components render.

Files to create:
- src/pages/admin/ProductList.tsx
- src/pages/admin/ProductEditor.tsx
- src/components/admin/AdminRouteGuard.tsx - Client-side auth/role gate

Authentication & Authorization:
- Require authenticated admin role via chosen provider (NextAuth/Clerk/Auth0)
  before rendering admin routes/components.
- AdminRouteGuard.tsx wraps all /admin/* routes — redirects unauthenticated
  or non-admin users to login or 403 page.
- Server-side guard checks on admin API endpoints (verify JWT/session and
  admin role before processing any write request).

Audit Logging:
- Log all product edits: who (user ID), what (product ID + field), when
  (timestamp), delta (old value → new value).
- Persist audit logs to an auditable store (database table, append-only log
  file, or external service like Datadog/Sentry).
- Surface recent edit history in the Admin UI for accountability.

Environment Isolation:
- Gate admin routes behind a feature flag (e.g., VITE_ENABLE_ADMIN=true)
  or build-time check so they are not exposed in unprotected production builds.
- Admin bundle should be code-split so it's never downloaded by regular users.

Features:
- List all products with search/filter
- Edit form with validation
- Download as JSON for commit
- View audit log of recent changes


5.4 GitHub Actions CI
----------------------
Automate validation on PRs.

Files to create:
- .github/workflows/validate-products.yml

================================================================================
RECOMMENDED IMPLEMENTATION ORDER
================================================================================

| Week  | Tasks                              | Impact                              |
|-------|------------------------------------|-------------------------------------|
| 1-2   | JSON extraction + validation CLI   | Foundation for everything else      |
| 3-4   | Dynamic imports + React Query      | 80% bundle reduction for current    |
| 5-6   | Edge functions API (search+filter) | Scalable to 10K products            |
| 7-8   | Web Worker scoring + indexing      | Fast client-side scoring            |
| 9-10  | Admin UI + CSV import              | Non-dev editing                     |

Why This Order?
1. JSON first - Everything else depends on data being in JSON format
2. Code splitting - Immediate performance win for existing users
3. API layer - Critical for scaling beyond 3K products
4. Web Workers - Nice-to-have optimization, not blocking
5. Admin UI - Improves DX but can manually edit JSON until then

================================================================================
CRITICAL FILES REFERENCE
================================================================================

| File                             | Purpose                              |
|----------------------------------|--------------------------------------|
| src/data/products.ts             | Central data access (refactor async) |
| src/lib/scoring/engine.ts        | Scoring logic (optimize for scale)   |
| src/types/products.ts            | Type definitions (Zod schema basis)  |
| src/hooks/use-recommendations.ts | React hooks (add React Query)        |
| vite.config.ts                   | Build config (add plugins)           |

================================================================================
VERIFICATION
================================================================================

After each phase:
1. Run `npm run build` - Verify bundle size reduction
2. Run `npm run dev` - Test quiz flow end-to-end
3. Check Lighthouse performance score
4. Verify all 4 quiz categories still return correct recommendations
