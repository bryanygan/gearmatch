# GearMatch Product Database Scaling Roadmap

## Target Architecture: Hybrid (Client Scoring + Thin API)

Goal: Scale to 3,000-10,000 products while maintaining fast quiz experience

Approach:
- Keep quiz/scoring client-side (fast, no network latency)
- Add thin API layer for search, pagination, and pre-filtering
- Products stored as JSON, served via edge functions

================================================================================
CURRENT STATE
================================================================================

| Metric            | Value                                              |
|-------------------|----------------------------------------------------|
| Total Products    | 662 individual exports + 378 in monitors array     |
|                   | Breakdown: audio: 198, keyboards: 279, mice: 184,  |
|                   | monitors: 1 array export (allMonitorProducts[378]) |
| Data Size         | 2.4 MB TypeScript (67K lines)                      |
| Largest File      | monitors.ts (1.1 MB) — exports a single array      |
|                   | (allMonitorProducts: MonitorProduct[]) not 378      |
|                   | individual exports like other category files        |
| Architecture      | All data bundled client-side in Vite SPA            |
| Query Pattern     | O(n) in-memory array filtering                      |

Pain Points:
- Large file sizes make editing difficult
- All products load on initial page visit
- No search capability
- No pagination or lazy loading
- Adding products requires code changes
- Will not scale beyond ~3,000 products without UX degradation

================================================================================
PHASE 1: QUICK WINS (No Backend Required)
================================================================================

1.1 Dynamic Imports by Category                              ✅ DONE (423d10c)
--------------------------------
Split product loading so only the active category loads.

Changes made:
- src/data/products.ts - Converted to async getters with dynamic import()
- src/hooks/use-recommendations.ts - Replaced useMemo with useQuery
- src/lib/scoring/engine.ts - Made scoring functions async
- src/hooks/use-prefetch-products.ts - New prefetch hook
- Quiz pages - Added prefetch calls
- Test files - Updated with async/await

Result: Separate chunks per category (mice 244KB, audio 244KB, keyboards 525KB,
monitors 913KB). 214 tests pass. Users download only the category they need.


1.2 Enable React Query Caching                               ✅ DONE (423d10c)
-------------------------------
Completed as part of 1.1 — useQuery with staleTime: Infinity, gcTime: 30min.

================================================================================
PHASE 2: EXTRACT DATA TO JSON
================================================================================

2.1 Convert TypeScript to JSON Files                       ✅ DONE (beb594d)
-------------------------------------
Move product data out of source code.

New structure:
  src/data/products/
    mice.json      (182 products, 348 KB)
    keyboards.json (278 products, 675 KB)
    monitors.json  (378 products, 1.1 MB)
    audio.json     (197 products, 332 KB)

Changes made:
- src/data/products/*.json - Product data as validated JSON files
- src/lib/schemas/product-schemas.ts - Zod validation schemas for all 4 categories
- scripts/convert-ts-to-json.ts - Validation script (npm run convert:products)
- src/data/products.ts - Async getters with dynamic import() for JSON files

Result: Removed 67K lines of TypeScript data files, replaced with validated JSON.
Zod schemas enforce all enums, required fields, and type constraints.


2.2 Build-Time Validation                                  ✅ DONE
--------------------------
Add Vite plugin to validate JSON at build time.

Changes made:
- vite-plugins/validate-products.ts - Vite plugin using Zod schemas
- vite.config.ts - Plugin registered in plugins array
- tsconfig.node.json - Includes vite-plugins directory

Result: Every `npm run build` and `npm run dev` validates all product JSON
against Zod schemas. Invalid data fails the build with clear error messages
showing the exact field path and issue. 214 tests pass.

================================================================================
PHASE 3: THIN API LAYER (Edge Functions)
================================================================================

Architecture: Static JSON on CDN + Vercel/Cloudflare Edge Functions

3.1 Product API Endpoints
--------------------------

Files to create:
- api/products/[category].ts - Get products by category (paginated)
- api/products/search.ts - Full-text search across products
- api/products/filter.ts - Pre-filter candidates for scoring

Endpoints:
  GET /api/products/mice?page=1&limit=50
  GET /api/products/search?q=razer&category=mouse
  POST /api/products/filter  (body: quiz answers, returns candidate IDs)


3.2 Security
-------------

Authentication & Authorization:
- GET endpoints (/api/products/[category], /api/products/search) are public
  read-only — no auth required.
- POST /api/products/filter is public but requires input validation (see below).
- Any future write endpoints (admin CRUD) require authenticated admin role via
  the chosen auth provider (NextAuth/Clerk/Auth0).

Input Validation & Sanitization:
- POST /api/products/filter: Validate quiz answer payloads against a strict
  Zod schema. Reject malformed requests, unexpected fields, and values outside
  allowed enums. Sanitize string inputs to prevent injection.
- GET /api/products/search: Validate and sanitize the `q` parameter (max
  length, strip special characters, escape for search backend).

Rate Limiting:
- GET /api/products/search: Rate limit to prevent abuse (e.g., 30 req/min/IP).
- POST /api/products/filter: Rate limit to prevent quiz-spam (e.g., 10 req/min/IP).
- Options: Upstash Redis (edge-compatible), Cloudflare Rate Limiting (if using
  CF Workers), or Vercel's built-in edge rate limiting.

CORS & Headers:
- Set explicit CORS policy: allow only the app's own origin in production.
- Recommended headers for edge deployments: Content-Security-Policy, Strict-
  Transport-Security (HSTS), X-Content-Type-Options: nosniff, X-Frame-Options.

Monitoring & Logging:
- Log request volumes, error rates, and latency per endpoint.
- Alert on unusual traffic patterns (potential abuse or scraping).


3.3 Smart Pre-Filtering
------------------------

Instead of scoring ALL products client-side:
1. Client sends quiz answers to /api/products/filter
2. API applies hard filters (wireless required? budget limit?)
3. Returns ~100-200 candidate product IDs
4. Client fetches only those products and scores them

Benefits:
- User downloads 200 products (~500KB) instead of 5,000 (~12MB)
- Scoring 200 products takes ~20ms instead of ~1 second
- Works great on mobile and low-end devices


3.4 Hosting Options
--------------------

| Platform           | Pros                                    | Cons                    |
|--------------------|-----------------------------------------|-------------------------|
| Vercel Edge        | Easy Vite integration, generous free    | Vendor lock-in          |
| Cloudflare Workers | Fastest, great free tier                | Separate deploy process |
| Netlify Functions  | Simple setup                            | Slower cold starts      |

Recommended: Vercel (if already using) or Cloudflare Workers (best performance)

================================================================================
PHASE 4: PERFORMANCE OPTIMIZATION
================================================================================

4.1 Web Worker Scoring
-----------------------
Move scoring engine to Web Worker to prevent UI blocking.

Files to create:
- src/workers/scoring-worker.ts
- src/lib/scoring/worker-client.ts

Benefits: UI stays responsive during scoring of thousands of products.


4.2 Pre-Filtering Strategy
---------------------------
Filter products before scoring to reduce workload.

Example: If user requires wireless, eliminate 50% of products before scoring.


4.3 Product Indexing
---------------------
Create indices for common attributes.

Example:
  const indices = {
    byCategory: { mouse: ['id1', 'id2'], keyboard: ['id3'] },
    byWireless: { true: ['id1'], false: ['id2', 'id3'] },
    byPriceTier: { budget: ['id2'], premium: ['id1'] }
  };

Benefits: O(1) lookups instead of O(n) filtering.


4.4 Client-Side Search
-----------------------
Add Fuse.js for fuzzy search on product names/brands.

Files to create:
- src/lib/search/index.ts
- src/hooks/use-product-search.ts
- src/components/search/SearchBar.tsx

================================================================================
PHASE 5: DEVELOPER EXPERIENCE
================================================================================

5.1 Validation CLI
-------------------
Pre-commit hook to validate product JSON.

Files to create:
- scripts/validate-products.ts
- .husky/pre-commit

Checks: Schema compliance, duplicate IDs, URL validity.


5.2 CSV Import/Export
----------------------
Allow bulk editing via spreadsheet.

Files to create:
- scripts/import-csv.ts
- scripts/export-csv.ts
- docs/csv-format.md - Example CSV/YAML samples and field rules

Cell Sanitization (sanitizeCell in import-csv.ts):
- Neutralize formula injection for values starting with '=', '+', '-', '@'
  by prefixing with a single quote or escaping.
- Normalize/strip UTF-8 BOM from input files and unify line endings (CRLF → LF).

Row Validation (validateRow in import-csv.ts):
- Strict schema field checks against product Zod schemas.
- URL format validation (and optional reachability check).
- Price range sanity checks (min > 0, min < max, within category norms).
- Required field enforcement (id, name, brand, category).
- Duplicate product ID detection/handling (warn or reject).
- Schema-versioning checks to detect field drift between CSV and current schema.

Dry-Run / Preview Mode:
- import-csv.ts --dry-run flag: Perform full validation without writing changes.
- Produce a validation report (pass/fail per row, warnings, summary stats).
- Exit with non-zero code if any validation errors found.

Export (export-csv.ts):
- Include all fields defined in the Zod schema.
- Add header comments with schema version and export timestamp.
- Document field rules alongside exports for reviewable commits.


5.3 Admin UI (Optional)
------------------------
Simple product editor within the app. Requires authentication and role-based
authorization before any admin routes or components render.

Files to create:
- src/pages/admin/ProductList.tsx
- src/pages/admin/ProductEditor.tsx
- src/components/admin/AdminRouteGuard.tsx - Client-side auth/role gate

Authentication & Authorization:
- Require authenticated admin role via chosen provider (NextAuth/Clerk/Auth0)
  before rendering admin routes/components.
- AdminRouteGuard.tsx wraps all /admin/* routes — redirects unauthenticated
  or non-admin users to login or 403 page.
- Server-side guard checks on admin API endpoints (verify JWT/session and
  admin role before processing any write request).

Audit Logging:
- Log all product edits: who (user ID), what (product ID + field), when
  (timestamp), delta (old value → new value).
- Persist audit logs to an auditable store (database table, append-only log
  file, or external service like Datadog/Sentry).
- Surface recent edit history in the Admin UI for accountability.

Environment Isolation:
- Gate admin routes behind a feature flag (e.g., VITE_ENABLE_ADMIN=true)
  or build-time check so they are not exposed in unprotected production builds.
- Admin bundle should be code-split so it's never downloaded by regular users.

Features:
- List all products with search/filter
- Edit form with validation
- Download as JSON for commit
- View audit log of recent changes


5.4 GitHub Actions CI
----------------------
Automate validation on PRs.

Files to create:
- .github/workflows/validate-products.yml

================================================================================
RECOMMENDED IMPLEMENTATION ORDER
================================================================================

| Week  | Tasks                              | Impact                              |
|-------|------------------------------------|-------------------------------------|
| 1-2   | JSON extraction + validation CLI   | Foundation for everything else      |
| 3-4   | Dynamic imports + React Query      | 80% bundle reduction for current    |
| 5-6   | Edge functions API (search+filter) | Scalable to 10K products            |
| 7-8   | Web Worker scoring + indexing      | Fast client-side scoring            |
| 9-10  | Admin UI + CSV import              | Non-dev editing                     |

Why This Order?
1. JSON first - Everything else depends on data being in JSON format
2. Code splitting - Immediate performance win for existing users
3. API layer - Critical for scaling beyond 3K products
4. Web Workers - Nice-to-have optimization, not blocking
5. Admin UI - Improves DX but can manually edit JSON until then

================================================================================
CRITICAL FILES REFERENCE
================================================================================

| File                             | Purpose                              |
|----------------------------------|--------------------------------------|
| src/data/products.ts             | Central data access (refactor async) |
| src/lib/scoring/engine.ts        | Scoring logic (optimize for scale)   |
| src/types/products.ts            | Type definitions (Zod schema basis)  |
| src/hooks/use-recommendations.ts | React hooks (add React Query)        |
| vite.config.ts                   | Build config (add plugins)           |

================================================================================
VERIFICATION
================================================================================

After each phase:
1. Run `npm run build` - Verify bundle size reduction
2. Run `npm run dev` - Test quiz flow end-to-end
3. Check Lighthouse performance score
4. Verify all 4 quiz categories still return correct recommendations
